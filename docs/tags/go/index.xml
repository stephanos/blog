<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>go on This Programming Life</title>
    <link>https://blog.stephanbehnke.com/tags/go/</link>
    <description>Recent content in go on This Programming Life</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 07 Aug 2016 15:43:23 +0000</lastBuildDate>
    
	<atom:link href="https://blog.stephanbehnke.com/tags/go/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>The Curious Case of the Merciless Compiler</title>
      <link>https://blog.stephanbehnke.com/the-curious-case-of-the-merciless-compiler/</link>
      <pubDate>Sun, 07 Aug 2016 15:43:23 +0000</pubDate>
      
      <guid>https://blog.stephanbehnke.com/the-curious-case-of-the-merciless-compiler/</guid>
      <description>In the movie 2001: A Space Odyssey the computer program HAL 9000 goes rogue, showing no mercy towards the space ship&amp;rsquo;s crew. That&amp;rsquo;s exactly how newcomers to the Go programming language must feel.
Since its introduction in 2009, the language has produced gigabytes worth of online debate about its very opinionated philosophy. Since it is a statically-compiled language, it has a compiler. And just like HAL the Go compiler is quite stubborn and - dare I say - merciless.</description>
    </item>
    
    <item>
      <title>Zero to Om - Act 6</title>
      <link>https://blog.stephanbehnke.com/zero-to-om-6/</link>
      <pubDate>Sun, 09 Nov 2014 18:00:00 +0000</pubDate>
      
      <guid>https://blog.stephanbehnke.com/zero-to-om-6/</guid>
      <description>Welcome to our next act. Today we&amp;rsquo;re going to meet a few additional libraries that&amp;rsquo;ll help us write great Om applications. Let&amp;rsquo;s get started!
As always, I strongly recommend reading the previous post first if you haven&amp;rsquo;t done so already.
 sablono In a previous post I showed you how the application&amp;rsquo;s UI is rendered:
(dom/div nil (header) (dom/input #js {:id &amp;#34;new-todo&amp;#34; :ref &amp;#34;newField&amp;#34; :placeholder &amp;#34;What needs to be done?</description>
    </item>
    
    <item>
      <title>Zero to Om - Act 5</title>
      <link>https://blog.stephanbehnke.com/zero-to-om-act-5/</link>
      <pubDate>Thu, 25 Sep 2014 12:51:00 +0000</pubDate>
      
      <guid>https://blog.stephanbehnke.com/zero-to-om-act-5/</guid>
      <description>In this part we will have a closer look at the app&amp;rsquo;s build configuration and discover what it can do for us. The source code can be found on GitHub.
Note: I strongly recommend reading the previous post first if you haven&amp;rsquo;t done so already.
 The Build Config The project&amp;rsquo;s build configuration is defined in project.clj. It is written in Clojure and looks like this:
;; project.clj, part 1 (defproject todomvc &amp;#34;0.</description>
    </item>
    
    <item>
      <title>Zero to Om - Act 4</title>
      <link>https://blog.stephanbehnke.com/zero-to-om-act-4/</link>
      <pubDate>Thu, 18 Sep 2014 08:57:00 +0000</pubDate>
      
      <guid>https://blog.stephanbehnke.com/zero-to-om-act-4/</guid>
      <description>Until now the application is rather boring. It just displays data. But we want to actually use it! In this post we will take a look at how the app reacts (no pun intented) to user input. The source code can be found on GitHub.
Note: I strongly recommend reading the previous post first if you haven&amp;rsquo;t done so already.
 Managing state is tricky. Each framework has its own mechanisms to detect and handle state changes.</description>
    </item>
    
    <item>
      <title>Zero to Om - Act 3</title>
      <link>https://blog.stephanbehnke.com/zero-to-om-act-3/</link>
      <pubDate>Thu, 11 Sep 2014 17:08:00 +0000</pubDate>
      
      <guid>https://blog.stephanbehnke.com/zero-to-om-act-3/</guid>
      <description>In this third post we&amp;rsquo;ll take a look at how the app is initialized and rendered. The source code can be found on GitHub.
Note: I strongly recommend reading the previous post first if you haven&amp;rsquo;t done so already.
For increased comprehension we will jump through the two files and not go through them from top to bottom.
 The State Most applications, at least the interesting ones, have some kind of state.</description>
    </item>
    
    <item>
      <title>Zero to Om - Act 2</title>
      <link>https://blog.stephanbehnke.com/zero-to-om-act-2/</link>
      <pubDate>Thu, 04 Sep 2014 05:18:00 +0000</pubDate>
      
      <guid>https://blog.stephanbehnke.com/zero-to-om-act-2/</guid>
      <description>In this second post we will look at actual ClojureScript source code, step by step. The source code can be found on GitHub.
Note: I strongly recommend reading the previous post first if you haven&amp;rsquo;t done so already.
 ClojureScript 101 Before we dive in we&amp;rsquo;ll look at the philosophy of ClojureScript.
Since ClojureScript is a Lisp dialect, it strips away most of the syntax you may know from other programming languages.</description>
    </item>
    
    <item>
      <title>Zero to Om</title>
      <link>https://blog.stephanbehnke.com/zero-to-om/</link>
      <pubDate>Mon, 25 Aug 2014 15:41:00 +0000</pubDate>
      
      <guid>https://blog.stephanbehnke.com/zero-to-om/</guid>
      <description>This is the first part of a series of blog posts about Om. If you don&amp;rsquo;t know anything about Om, don&amp;rsquo;t worry! You&amp;rsquo;ll learn everything step by step. Here are the basics: Om is a ClojureScript interface to Facebook&amp;rsquo;s React. If that doesn&amp;rsquo;t ring any bells, again, don&amp;rsquo;t worry!
NOTE: I just started learning React.js, ClojureScript and Om. So this is my way of trying to learn this myself: By taking you on the ride with me.</description>
    </item>
    
  </channel>
</rss>